name: Divary CI/CD

on:
  push:
    branches: [develop, main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: Generate application-prod.yml
        run: |
          mkdir -p ./src/main/resources
          cat << 'EOF' > ./src/main/resources/application-prod.yml
          ${{ secrets.APPLICATION_PROD_YML }}
          EOF
        shell: bash

      - name: Grant permission to gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew build -x test --build-cache --parallel

      - name: Docker 이미지 이름 설정
        id: docker_meta
        run: echo "image_name=divary-app" >> $GITHUB_OUTPUT

      - name: Docker Buildx 설정
        uses: docker/setup-buildx-action@v3

      - name: Docker 이미지 빌드
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false # 레지스트리에 푸시하지 않음
          tags: ${{ steps.docker_meta.outputs.image_name }}:latest
          load: true # 이미지를 로컬 Docker 데몬으로 로드

      - name: Docker 이미지를 tar 파일로 저장
        run: docker save ${{ steps.docker_meta.outputs.image_name }}:latest -o divary-image.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: divary-image-artifact
          path: divary-image.tar # tar 파일 업로드

  deploy:
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: divary-image-artifact # 빌드 잡에서 업로드한 아티팩트 이름
          path: ./deploy-package

      - name: Deploy to EC2
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_KEY }}
          EC2_USERNAME: ${{ secrets.EC2_USERNAME }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          PROD_ENV: ${{ secrets.APPLICATION_PROD_ENV }}
        run: |
          # SSH 키 설정
          cat << KEY_EOF > private_key.pem
          $EC2_SSH_KEY
          KEY_EOF
          chmod 600 private_key.pem

          # 환경변수 파일 생성
          cat << ENV_EOF > .env
          $PROD_ENV
          ENV_EOF

          # Docker 이미지(.tar)와 환경변수 파일(.env)을 EC2로 전송
          scp -i private_key.pem -o StrictHostKeyChecking=no ./deploy-package/divary-image.tar $EC2_USERNAME@$EC2_HOST:/home/$EC2_USERNAME/divary-image.tar
          scp -i private_key.pem -o StrictHostKeyChecking=no .env $EC2_USERNAME@$EC2_HOST:/home/$EC2_USERNAME/.env

          # EC2에서 Docker 컨테이너 실행 스크립트
          ssh -i private_key.pem -o StrictHostKeyChecking=no $EC2_USERNAME@$EC2_HOST << 'EOF'
            set -e
            cd /home/$EC2_USERNAME

            # 1. tar 파일로부터 Docker 이미지 로드
            docker load -i divary-image.tar

            # 2. 기존 컨테이너 중지 및 제거 (오류 무시)
            docker stop divary-app || true
            docker rm divary-app || true

            # 3. 새로운 컨테이너 실행
            # --env-file: .env 파일의 모든 변수를 컨테이너 환경변수로 주입
            # -d: 백그라운드 실행
            # -p: 포트 포워딩 (호스트:컨테이너)
            # --restart always: 서버 재부팅 시 컨테이너 자동 재시작
            docker run \
              --name divary-app \
              -d \
              -p 8080:8080 \
              --restart always \
              --env-file .env \
              divary-app:latest

            # 4. 사용하지 않는 Docker 이미지 정리 (디스크 용량 확보)
            docker image prune -af

            echo "🚀 Deployment Successful!"
          EOF
          
          # 임시 파일 정리
          rm -f private_key.pem .env
